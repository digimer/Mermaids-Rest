#include <Wire.h>
#include <math.h>
#include <inttypes.h>
#include <Adafruit_MCP4725.h>
/*
  Mermaid's Rest - Helm Controls

  - Madison Kelly - digital.mermaid@gmail.com
    - Thanks to several contributors!
  - Last Updated  - Feb. 11, 2024

  References and Sources
  - MCP4725 Tutorial - Electronoobs
    - https://www.youtube.com/watch?v=SgPbzAWIwlk
*/

// Remove this define in order to stop outputting to serial
#define DEBUG

Adafruit_MCP4725 dac;
// Set this value to 9, 8, 7, 6 or 5 to adjust the resolution
#define DAC_RESOLUTION   (9)

// Switches
static const int32_t ThrottleStopSwitch = 12; // Sets DAC to 2.5v, sets FootSwitchPin to 0.
static const int32_t FootSwitch         = 11; // Used to close the 12v circuit to Kelly Pin 15

// the setup function runs once when you press reset or power the board
void setup() {
  // Setup so we can read the serial port
#ifdef DEBUG
  Serial.begin(9600);
  Serial.println("Mermaid's Rest - Helm Controls");
#endif
  dac.begin(0x62);
}

// Range for a 12-bit DAC
static const int32_t dacMinimum        = 50;     // The TPS Dead Low is set to 0.05vDC, 6 == 5.73vDC
static const int32_t dacMaximum        = 4054;   // The TPS Dead High is set to 4.95vDC, 4090 == 4993.4vDC
static const int32_t dacVoltageMaximum = 4950;   // Anything above 4.95vDC is considered a shorted throttle
static const int32_t dacVoltageMinimum = 50;     // Anything below 0.05vDC is considered disconnected throttle
static const float   stepVoltage       = 1.2207; // mV per step, 1.2207v (5000mv / 4096 steps)

// How long to wait between loops (ms)
static const int32_t delayTime = 100;

// How many records to use when calculating our rolling average. This needs to
// be proportional to 'delayTime'
static const int32_t averageOver = 32;

// These might need to be tuned per helm control
static const int32_t dacNeutral      = 2010;    // Tested on this DAC, not mathmatically accurate
static const int32_t dacNeutralStart = 1965;
static const int32_t dacNeutralEnd   = 2130;

// -- Potentiometer values as read by digitalRead()
// Reverse starts at high pot and counts down
static const int32_t reverseMaximum = 265;
static const int32_t reverseMinimum = 465;

// Forward starts at low pot and counts up
static const int32_t forwardMinimum = 550;
static const int32_t forwardMaximum = 750;

// Reverse starts at high pot and counts down
static const int32_t reverseSensorSteps = (reverseMinimum - reverseMaximum);
static const int32_t forwardSensorSteps = (forwardMaximum - forwardMinimum);

// Calculate the nuetral range midpoint
static const int32_t neutralMidPoint = (reverseMinimum + forwardMinimum)/2;

// This is for showing percentages.
static const int32_t reversePercentSteps = 100 / reverseSensorSteps;
static const int32_t forwardPercentSteps = 100 / forwardSensorSteps;

// This is used to know how many samples we have in our rolling average. It's
// main use is to deal with start-up when we don't yet have a full array.
int32_t sampleOver       = 0;
int32_t smoothedPotValue = 0;
int32_t oldestPotIndex   = 0;  // This is the array index with the oldest value
int32_t potTotal         = 0;
int32_t potLoopCount     = 0;
int32_t potArray[averageOver];

// The foot switch (Kelly pin 15, 12v) needs to be '1' for the throttle to work.
bool FootSwitchValue = 0;

// the loop function runs over and over again forever
void loop() {
  // Read the control switch. If this is LOW, we set the motor control voltage to 2.5v / neutral
  int32_t mainSwitchVal = digitalRead(ThrottleStopSwitch);

  // Read the helm position potentiometer if the main switch is on. The switch goes to '1' if the switch is
  // disconnected, so we need to see '0' to know the switch is properly engaged.
  int32_t sensorValue;
  if (mainSwitchVal == 1) {
    // Switch is on (or disconnected), force the sensorValue to the middle of the neutral range
    sensorValue = neutralMidPoint;
    // Open the Foot Switch, also
    FootSwitchValue = 0;
  } else {
    // only read the sensor value if the main switch is on
    sensorValue     = analogRead(A0);
    sensorValue     = constrain(sensorValue, reverseMaximum, forwardMaximum);
    FootSwitchValue = 1;
  }

  // Smooth out the sensorValue over 'averageOver' samples.
  potArray[oldestPotIndex] = sensorValue;
  oldestPotIndex = oldestPotIndex + 1;
  if (oldestPotIndex >= averageOver) {
    oldestPotIndex = 0;
  }
  potLoopCount = averageOver;
  if (sampleOver < averageOver){
    sampleOver++;
    potLoopCount = sampleOver;
  }
  potTotal = 0;
  for (byte i = 0; i < potLoopCount; i = i + 1) {
    potTotal = potTotal + potArray[i];
  }
  smoothedPotValue = (int)roundf((float)potTotal / (float)potLoopCount);

  int32_t dacValue = dacNeutral;  // Default to 2.5v
  if (smoothedPotValue <= reverseMinimum)
  {
    // 465 = Min Reverse = DAC 1965 = 2358 mV
    // 265 = Max Reverse = DAC    0 -    0 mV
    //dacValue = map(smoothedPotValue, reverseMaximum, reverseMinimum, dacVoltageMinimum, dacNeutralStart);
    dacValue = map(smoothedPotValue, reverseMaximum, reverseMinimum, dacMinimum, dacNeutralStart);
  }
  else if (smoothedPotValue >= forwardMinimum)
  {
    // 750 = Max Forward = DAC 4095 = 4914 mV
    // 550 = Min Forward = DAC 2130 = 2556 mV
    //dacValue = map(smoothedPotValue, forwardMinimum, forwardMaximum, dacNeutralEnd, dacVoltageMaximum);
    dacValue = map(smoothedPotValue, forwardMinimum, forwardMaximum, dacNeutralEnd, dacMaximum);
  }
  else
  {
    // In the Neutral deadzone, we want 2500v, DAC = 2084 (2500.8 mV)
    dacValue = dacNeutral;
  }

#ifdef DEBUG
  // -- Here we calculate ranges.
  int32_t IntegerDACValue = roundf(dacValue);
  int32_t IntegerVoltage  = IntegerDACValue * stepVoltage;

  Serial.print("Switches (Oh poo/foot): [");
  Serial.print(mainSwitchVal);
  Serial.print("/");
  Serial.print(FootSwitchValue);
  Serial.print("], Sensor raw/smoothed: [");
  Serial.print(sensorValue);
  Serial.print("/");
  Serial.print(smoothedPotValue);
  Serial.print("], DAC: [");
  Serial.print(IntegerDACValue);
  Serial.print("] (");
  //Serial.print("step voltage: [");
  //Serial.print(stepVoltage);
  //Serial.print("], ");
  Serial.print(IntegerVoltage);
  Serial.print(" mV)");

  if (smoothedPotValue <= reverseMaximum)
  {
    Serial.print(" - Reverse 100%");
  }
  else if (smoothedPotValue >= forwardMaximum)
  {
    Serial.print(" - Forward 100%");
  }
  else if ((smoothedPotValue >= reverseMaximum) && (smoothedPotValue <= reverseMinimum))
  {
    int32_t range      = reverseMinimum - reverseMaximum;
    int32_t position   = smoothedPotValue - reverseMinimum;
    int32_t percentage = -(int)roundf(((float)position / (float)range) * 100.0f);
    Serial.print(" - Reverse ");
    Serial.print(percentage);
    Serial.print("%");
  }
  else if ((smoothedPotValue >= forwardMinimum) && (smoothedPotValue <= forwardMaximum))
  {
    int32_t range      = forwardMaximum - forwardMinimum;
    int32_t position   = smoothedPotValue - forwardMinimum;
    int32_t percentage = (int)roundf(((float)position / (float)range) * 100.0f);
    Serial.print(" - Forward ");
    Serial.print(percentage);
    Serial.print("%");
  }
  else
  {
    Serial.print(" - Neutral");
  }

  Serial.println("");
 #endif

  // Update the DAC
  dacValue = constrain(dacValue, dacMinimum, dacMaximum);
  dac.setVoltage(dacValue, false);

  // Set the Foot Switch
  //digitalWrite(FootSwitch, FootSwitchValue);

  // Read 10/sec
  delay(delayTime);
}
