#include <Wire.h>
#include <Adafruit_MCP4725.h>
/*
  Mermaid's Rest - Helm Controls

  - Madison Kelly - digital.mermaid@gmail.com
  - Last Updated  - Jan. 26, 2024

  References and Sources
  - MCP4725 Tutorial - Electronoobs
    - https://www.youtube.com/watch?v=SgPbzAWIwlk
  
*/

Adafruit_MCP4725 dac;
// Set this value to 9, 8, 7, 6 or 5 to adjust the resolution
#define DAC_RESOLUTION   (9)

// Switches
int mainSwitchPin = 12; // When this switch is open, the motor signal will be set to 2.5v (idle)

// the setup function runs once when you press reset or power the board
void setup() {
  // Setup so we can read the serial port
  Serial.begin(9600);
  Serial.println("MCP4725 Test");
  dac.begin(0x62);
}

// Range for a 12-bit DAC
int dacMinimum        = 0;
int dacMaximum        = 4095;
int dacVoltageMaximum = 5000;
int davVoltageMinimum = 0;

// How long to wait between loops (ms)
int delayTime = 500;

// These might need to be tuned per helm control
int dacNeutral      = 2010;	// Tested on this DAC, not mathmatically accurate
int dacNeutralStart = 1965;
int dacNeutralEnd   = 2130;

// -- Potentiometer values as read by digitalRead()
// Reverse starts at high pot and counts down
int reverseMaximum = 265;
int reverseMinimum = 465;

// Forward starts at low pot and counts up
int forwardMinimum = 550;
int forwardMaximum = 750;

// -- Here we calculate ranges.
int dacVoltageSteps = (dacVoltageMaximum - davVoltageMinimum) / dacMaximum;

// Reverse starts at high pot and counts down
int reverseSensorSteps = (reverseMinimum - reverseMaximum);
int reverseDACSteps    = (dacNeutralStart - dacMinimum);

// Forward starts at low pot and counts up
int forwardSensorSteps = (forwardMaximum - forwardMinimum);
int forwardDACSteps    = (dacMaximum - dacNeutralEnd);

// Calulate the DAC steps per potentiometer steps
int reverseDACStepsPerSensorSteps = reverseDACSteps / reverseSensorSteps;
int forwardDACStepsPerSensorSteps = forwardDACSteps / forwardSensorSteps;

// This is for showing percentages.
int reversePercentSteps = 100 / reverseSensorSteps;
int forwardPercentSteps = 100 / forwardSensorSteps;

// the loop function runs over and over again forever
void loop() {
  // Read the control switch. If this is LOW, we set the motor control voltage to 2.5v / neutral
  int mainSwitchVal = digitalRead(mainSwitchPin);

  // Read the helm position potentiometer
  int sensorValue = analogRead(A0);
  // Show the pot reading.

  int dacValue = dacNeutral;  // Default to 2.5v
  if (mainSwitchVal == 0) {
    // Switch is off, set DAC to 2010 / output voltage 2.5v to set the controller to neutral
    dacValue = dacNeutral;
  }
  else if ((sensorValue >= reverseMaximum) && (sensorValue <= reverseMinimum))
  {
    // 465 = Min Reverse = DAC 1965 = 2358 mV
    // 265 = Max Reverse = DAC    0 -    0 mV
    dacValue = ((sensorValue - reverseMaximum) * reverseDACStepsPerSensorSteps) + dacMinimum;
  }
  else if ((sensorValue >= forwardMinimum) && (sensorValue <= forwardMaximum))
  {
    // 750 = Max Forward = DAC 4095 = 4914 mV
    // 550 = Min Forward = DAC 2130 = 2556 mV
    dacValue = ((sensorValue - forwardMinimum) * forwardDACStepsPerSensorSteps) + dacNeutralEnd;
  }
  else if (sensorValue > forwardMaximum)
  {
    // Still Max Forward, DAC 4095
    dacValue = dacMaximum;
  }
  else if (sensorValue < reverseMaximum)
  {
    // Still Max Reverse, DAC 0
    dacValue = 0;
  }
  else
  {
    // In the Neutral deadzone, we want 2500v, DAC = 2084 (2500.8 mV)
    dacValue = dacNeutral;
  }

  // Round the DAC value
  int IntegerDACValue = int(dacValue + 0.5);
  int DACVoltage      = IntegerDACValue * dacVoltageSteps;
  int IntegerVoltage  = int(DACVoltage + 0.5);

  Serial.print("Switch: [");
  Serial.print(mainSwitchVal);
  Serial.print("], Sensor: [");
  Serial.print(sensorValue);
  Serial.print("], DAC: [");
  Serial.print(IntegerDACValue);
  Serial.print("] (");
  Serial.print(IntegerVoltage);
  Serial.print(" mV)");
  
  if (sensorValue <= reverseMaximum)
  {
    Serial.print(" - Reverse 100%");
  }
  elsif (sensorValue >= forwardMaximum)
  {
    Serial.print(" - Forward 100%");
  }
  elsif ((sensorValue >= reverseMaximum) && (sensorValue <= reverseMinimum))
  {
    int percentage = int((reversePercentSteps * (reverseMinimum - sensorValue)) + 0.5);
    Serial.print(" - Forward ");
    Serial.print(percentage);
    Serial.print("%");
  }
  elsif ((sensorValue >= forwardMinimum) && (sensorValue <= forwardMaximum))
  {
    int percentage = int((forwardPercentSteps * (sensorValue - forwardMinimum)) + 0.5);
    Serial.print(" - Reverse ");
    Serial.print(percentage);
    Serial.print("%");
  }
  else
  {
    Serial.print(" - Neutral");
  }
  
  if (IntegerDACValue > dacMaximum)
  {
    IntegerDACValue = dacMaximum;
    Serial.print(" - Too High! Setting to: [");
    Serial.print(IntegerDACValue);
    Serial.print("]");
  }
  elsif ((IntegerDACValue > dacNeutralStart) && (IntegerDACValue < dacNeutralEnd) && (IntegerDACValue != dacNeutral))
  {
    IntegerDACValue = dacNeutral;
    Serial.print(" - Into neutral! Setting to: [");
    Serial.print(IntegerDACValue);
    Serial.print("]");
  }
  Serial.println("");
 
  // Update the DAC
  dac.setVoltage(dacValue, false);

  // Read 10/sec
  delay(delayTime); 
}
