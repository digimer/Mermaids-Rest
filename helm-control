#include <Wire.h>
#include <math.h>
#include <inttypes.h>
#include <Adafruit_MCP4725.h>
/*
  Mermaid's Rest - Helm Controls

  - Madison Kelly - digital.mermaid@gmail.com
    - Thanks to several contributors!
  - Last Updated  - Feb. 11, 2024

  References and Sources
  - MCP4725 Tutorial - Electronoobs
    - https://www.youtube.com/watch?v=SgPbzAWIwlk
*/

// Remove this define in order to stop outputting to serial
#define DEBUG

Adafruit_MCP4725 ThrottleDAC;
Adafruit_MCP4725 RegenDAC;
// Set this value to 9, 8, 7, 6 or 5 to adjust the resolution
#define DAC_RESOLUTION   (9)

// Switches
static const int32_t ThrottleStopSwitch = 12; // Sets DAC to 2.5v, sets FootSwitchPin to 0.
static const int32_t FootSwitch         = 11; // Used to close the 12v circuit to Kelly Pin 15
static const int32_t SpeedHigh          = 10; // Used to close the 12v circuit to Kelly Pin 12
static const int32_t SpeedLow           = 9;  // Used to close the 12v circuit to Kelly Pin 22

// the setup function runs once when you press reset or power the board
void setup() {
  // Setup so we can read the serial port
#ifdef DEBUG
  Serial.begin(9600);
  Serial.println("Mermaid's Rest - Helm Controls");
#endif
  ThrottleDAC.begin(0x62); // Leave default
  RegenDAC.begin(0x63);    // Tie Regen DAC's A0 to VDD to
}

// Range for the Throttle's 12-bit DAC
static const int32_t ThrottleDACMinimum  = 50;     // The TPS Dead Low is set to 0.05vDC, 6 == 5.73vDC
static const int32_t ThrottleDACMaximum  = 4054;   // The TPS Dead High is set to 4.95vDC, 4090 == 4993.4vDC
static const float   ThrottleStepVoltage = 1.2207; // mV per step, 1.2207v (5000mv / 4096 steps)

// Range for the Regen's 12-bit DAC
static const int32_t RegenDACMinimum  = 50;     // The TPS Dead Low is set to 0.05vDC, 6 == 5.73vDC
static const int32_t RegenDACMaximum  = 4054;   // The TPS Dead High is set to 4.95vDC, 4090 == 4993.4vDC
static const float   RegenStepVoltage = 1.2207; // mV per step, 1.2207v (5000mv / 4096 steps)

// How long to wait between loops (ms)
static const int32_t delayTime = 100;

// How many records to use when calculating our rolling average. This needs to
// be proportional to 'delayTime'
static const int32_t ThrottleAverageOver = 32;

// These might need to be tuned per helm control
static const int32_t ThrottleDACNeutral      = 2010;    // Tested on this DAC, not mathmatically accurate
static const int32_t ThrottleDACNeutralStart = 1965;
static const int32_t ThrottleDACNeutralEnd   = 2130;

// -- Potentiometer values as read by digitalRead()
// Reverse starts at high pot and counts down
static const int32_t reverseMaximum = 265;
static const int32_t reverseMinimum = 465;

// Forward starts at low pot and counts up
static const int32_t forwardMinimum = 550;
static const int32_t forwardMaximum = 750;

// Reverse starts at high pot and counts down
static const int32_t reverseSensorSteps = (reverseMinimum - reverseMaximum);
static const int32_t forwardSensorSteps = (forwardMaximum - forwardMinimum);

// Calculate the nuetral range midpoint
static const int32_t neutralMidPoint = (reverseMinimum + forwardMinimum)/2;

// This is for showing percentages.
static const int32_t reversePercentSteps = 100 / reverseSensorSteps;
static const int32_t forwardPercentSteps = 100 / forwardSensorSteps;

// This is used to know how many samples we have in our rolling average. It's
// main use is to deal with start-up when we don't yet have a full array.
int32_t sampleOver               = 0;
int32_t ThrottleSmoothedPotValue = 0;
int32_t oldestPotIndex           = 0;  // This is the array index with the oldest value
int32_t potTotal                 = 0;
int32_t potLoopCount             = 0;
int32_t potArray[ThrottleAverageOver];

// The foot switch (Kelly pin 15, 12v) needs to be '1' for the throttle to work.
bool FootSwitchValue = 0;

// the loop function runs over and over again forever
void loop() {
  // Read the control switch. If this is LOW, we set the motor control voltage to 2.5v / neutral
  int32_t mainSwitchVal = digitalRead(ThrottleStopSwitch);

  // Read the helm position potentiometer if the main switch is on. The switch goes to '1' if the switch is
  // disconnected, so we need to see '0' to know the switch is properly engaged.
  int32_t sensorValue;
  if (mainSwitchVal == 1) {
    // Switch is on (or disconnected), force the sensorValue to the middle of the neutral range
    sensorValue = neutralMidPoint;
    // Open the Foot Switch, also
    FootSwitchValue = 0;
  } else {
    // only read the sensor value if the main switch is on
    sensorValue     = analogRead(A0);
    sensorValue     = constrain(sensorValue, reverseMaximum, forwardMaximum);
    FootSwitchValue = 1;
  }

  // Smooth out the sensorValue over 'ThrottleAverageOver' samples.
  potArray[oldestPotIndex] = sensorValue;
  oldestPotIndex = oldestPotIndex + 1;
  if (oldestPotIndex >= ThrottleAverageOver) {
    oldestPotIndex = 0;
  }
  potLoopCount = ThrottleAverageOver;
  if (sampleOver < ThrottleAverageOver){
    sampleOver++;
    potLoopCount = sampleOver;
  }
  potTotal = 0;
  for (byte i = 0; i < potLoopCount; i = i + 1) {
    potTotal = potTotal + potArray[i];
  }
  ThrottleSmoothedPotValue = (int)roundf((float)potTotal / (float)potLoopCount);

  int32_t ThrottleDACValue = ThrottleDACNeutral;  // Default to 2.5v
  if (ThrottleSmoothedPotValue <= reverseMinimum)
  {
    // 465 = Min Reverse = DAC 1965 = 2358 mV
    // 265 = Max Reverse = DAC    0 -    0 mV
    ThrottleDACValue = map(ThrottleSmoothedPotValue, reverseMaximum, reverseMinimum, ThrottleDACMinimum, ThrottleDACNeutralStart);
  }
  else if (ThrottleSmoothedPotValue >= forwardMinimum)
  {
    // 750 = Max Forward = DAC 4095 = 4914 mV
    // 550 = Min Forward = DAC 2130 = 2556 mV
    ThrottleDACValue = map(ThrottleSmoothedPotValue, forwardMinimum, forwardMaximum, ThrottleDACNeutralEnd, ThrottleDACMaximum);
  }
  else
  {
    // In the Neutral deadzone, we want 2500v, DAC = 2084 (2500.8 mV)
    ThrottleDACValue = ThrottleDACNeutral;
  }

#ifdef DEBUG
  // -- Here we calculate ranges.
  int32_t IntegerDACValue = roundf(ThrottleDACValue);
  int32_t IntegerVoltage  = IntegerDACValue * ThrottleStepVoltage;

  Serial.print("Switches (Oh poo/foot): [");
  Serial.print(mainSwitchVal);
  Serial.print("/");
  Serial.print(FootSwitchValue);
  Serial.print("], Sensor raw/smoothed: [");
  Serial.print(sensorValue);
  Serial.print("/");
  Serial.print(ThrottleSmoothedPotValue);
  Serial.print("], DAC: [");
  Serial.print(IntegerDACValue);
  Serial.print("] (");
  //Serial.print("step voltage: [");
  //Serial.print(ThrottleStepVoltage);
  //Serial.print("], ");
  Serial.print(IntegerVoltage);
  Serial.print(" mV)");

  if (ThrottleSmoothedPotValue <= reverseMaximum)
  {
    Serial.print(" - Reverse 100%");
  }
  else if (ThrottleSmoothedPotValue >= forwardMaximum)
  {
    Serial.print(" - Forward 100%");
  }
  else if ((ThrottleSmoothedPotValue >= reverseMaximum) && (ThrottleSmoothedPotValue <= reverseMinimum))
  {
    int32_t range      = reverseMinimum - reverseMaximum;
    int32_t position   = ThrottleSmoothedPotValue - reverseMinimum;
    int32_t percentage = -(int)roundf(((float)position / (float)range) * 100.0f);
    Serial.print(" - Reverse ");
    Serial.print(percentage);
    Serial.print("%");
  }
  else if ((ThrottleSmoothedPotValue >= forwardMinimum) && (ThrottleSmoothedPotValue <= forwardMaximum))
  {
    int32_t range      = forwardMaximum - forwardMinimum;
    int32_t position   = ThrottleSmoothedPotValue - forwardMinimum;
    int32_t percentage = (int)roundf(((float)position / (float)range) * 100.0f);
    Serial.print(" - Forward ");
    Serial.print(percentage);
    Serial.print("%");
  }
  else
  {
    Serial.print(" - Neutral");
  }

  Serial.println("");
 #endif

  // Update the DAC
  ThrottleDACValue = constrain(ThrottleDACValue, ThrottleDACMinimum, ThrottleDACMaximum);
  ThrottleDAC.setVoltage(ThrottleDACValue, false);

  // Set the Foot Switch
  //digitalWrite(FootSwitch, FootSwitchValue);

  // Read 10/sec
  delay(delayTime);
}
