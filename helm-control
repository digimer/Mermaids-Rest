#include <Wire.h>
#include <math.h>
#include <inttypes.h>
#include <Adafruit_MCP4725.h>
/*
  Mermaid's Rest - Helm Controls

  - Madison Kelly - digital.mermaid@gmail.com
  - Last Updated  - Jan. 27, 2024

  References and Sources
  - MCP4725 Tutorial - Electronoobs
    - https://www.youtube.com/watch?v=SgPbzAWIwlk

*/

Adafruit_MCP4725 dac;
// Set this value to 9, 8, 7, 6 or 5 to adjust the resolution
#define DAC_RESOLUTION   (9)

// NOTE(jokke): For clarity lets define all these constants before setup so one day when things gets bit
// more complicated we don't need to hunt them all over the place. And turn them upper case so we
// recognize them easily.

// Switches
// As we are fine with the 0-256 lets save the microcontroller some hassle
const byte ENGINE_IDLE_PIN = 12; // When this switch is open, the motor signal will be set to 2.5v (idle)

// Range for a 12-bit DAC
const int16_t DAC_MIN        = 0;
const int16_t DAC_MAX        = 4095;
const int16_t DAC_VOLT_MIN = 0;
const int16_t DAC_VOLT_MAX = 5000;

// How long to wait between loops (ms)
const int16_t LOOP_DELAY_MS = 500;

// These might need to be tuned per helm control
const int16_t DAC_NEUTRAL      = 2010;	// Tested on this DAC, not mathmatically accurate
const int16_t DAC_NEUTRAL_START = 1965;
const int16_t DAC_NEUTRAL_END   = 2130;

// NOTE(jokke):These would make a lot of sense to calibrate, so lets not flag them constants.
// Easyish way to do that would be adding another button and do the calibration loop if it's
// pushed when the IdleSwitch is on idle. Then just set the throttle to max rev, push the button
// min rev, push the button, min forward, push the button, max forward, push the button, write
// the values to eeprom and let the setup to overwrite from the eeprom at the start.

// -- Potentiometer values as read by digitalRead()
// Reverse starts at high pot and counts down
int16_t reverseMaximum = 265;
int16_t reverseMinimum = 465;

// Forward starts at low pot and counts up
int16_t forwardMinimum = 550;
int16_t forwardMaximum = 750;

// These variables might get populated in the loop
bool engineIdleVal = 0; // We initialize with 0 to make sure we stay in neutral until successful read

int16_t throttleValue = 505; // We initilize this in the neutral range too for safety.
int16_t dacValue = DAC_NEUTRAL;
int32_t mappedThrottle = DAC_NEUTRAL; // ATTN: This is _not_ unsigned integer for safety.
int16_t integerVoltage = 0;

byte precentage = 0;


// the setup function runs once when you press reset or power the board
void setup() {
  // Setup so we can read the serial port
  Serial.begin(9600);
  Serial.println("MCP4725 Test");
  dac.begin(0x62);
}

// the loop function runs over and over again forever
void loop() {
  // Read the control switch. If this is LOW, we set the motor control voltage to 2.5v / neutral
  engineIdleVal = digitalRead(ENGINE_IDLE_PIN);

  // Read the helm position potentiometer
  throttleValue = analogRead(A0);
  // Show the pot reading.

  if (EngineIdleVal == 0) || ((throttleValue > reverseMinimum) && (throttleValue < forwardMinimum))
  {
    // Switch is off, set DAC to 2010 / output voltage 2.5v to set the controller to neutral
    dacValue = DAC_NEUTRAL;
  }
  else
  {
    // NOTE(jokke): First we map the throttle input range to the range the DAC is happy to take in.
    // Note how the upper case constant names pops and we know exactly where these are coming from.
    mappedThrottle = map(throttleValue, reverseMaximum, forwardMaximum, DAC_MIN, DAC_MAX);
    // The map(x, fromLOW, fromHigh, toLow, toHigh) just does all that math of step sizes and their
    // rounding to integers. _But_ it does not constrain the values to the range. So we need:
    dacValue = constrain(mappedThrottle, DAC_MIN, DAC_MAX); // this ensures that we're in the range.
  }

  integerVoltage  = (dacValue * 5000) / 4095;

  Serial.print("Switch: [");
  Serial.print(EngineIdleVal);
  Serial.print("], Sensor: [");
  Serial.print(throttleValue);
  Serial.print("], DAC: [");
  Serial.print(dacValue);
  Serial.print("] (");
  Serial.print(integerVoltage);
  Serial.print(" mV)");

  if (dacValue == DAC_MIN) // due to the constrain() on L98 we will never again be out of bound
  {
    Serial.print(" - Reverse 100%");
  }
  else if (dacValue == DAC_MAX)
  {
    Serial.print(" - Forward 100%");
  }
  else if (dacValue < DAC_NEUTRAL_START)
  {
    // NOTE(jokke): Lets simplify this with the map too, we have already constrained the values
    precentage = map(dacValue, DAC_MIN, DAC_MAX, 0, 100);
    Serial.print(" - Reverse ");
    Serial.print(percentage, DEC); // Here we use neat feature of print that allows printing byte in decimal
    Serial.print("%");
  }
  else if (dacValue > DAC_NEUTRAL_END)
  {
    precentage = map(dacValue, DAC_MIN, DAC_MAX, 0, 100);
    Serial.print(" - Forward ");
    Serial.print(percentage, DEC);
    Serial.print("%");
  }
  else
  {
    Serial.print(" - Neutral");
  }
  Serial.println("");

  // Update the DAC
  dac.setVoltage(dacValue, false);

  // Read 10/sec
  delay(LOOP_DELAY_MS);
}
